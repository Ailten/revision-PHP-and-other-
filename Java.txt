
// default programme console.
public class Main {
    public static void main(String[] args){
        System.out.println("Test");
    }
}



System.out.println("Test");  // print a string.
// comment.  // comment.
String myStr = "MyString";  // variable string (warning, string in Java is process as Instance, so can't be comparate as equal).
int myInt = 15;  // variable int.
final int CONST_INT = 15;  // constante int (can't be change).
char myChar = 'a';  // var char.
boolean myBool = true;  // var boolean.
float myFloat = 0.5f;  // var float.
double myDouble = 0.5d;  // var double (decimal with pressision).
(int) 0.5d  // cast double into int (floor).

"Test".toLowerCase()  // lower case.
"Test".charAt(0)  // get char at an index. (same as [0] indexor).
"Test".equals("Test")  // verify if string are the same (important, to compare equality of two string both distinct instance).
"Test".trim()  // remove space at start and end.

Math.max(2, 5)  // return the value the bigest (5).
Math.min(2, 5)  // return the value the lowest (2).
Math.sqrt(25)  // return the square root (5).
Math.abs(-5)  // return the abs value (5).
Math.pow(5, 2)  // return the exposent (25).
Math.floor(0.5f)  // return floor value (0).
Math.ceil(0.5f)  // return ceil value (1).
Math.round(0.9f)  // return round value (1).
Math.random()  // return a random number (between 0 and 0.9999...).

if (myFloat < 0.5f) {}  // if.
else if (myFloat < 0.5f) {}  // else if.
else {}  // else.
int myInt = (myFloat < 0.5f)? 0 : 1);  // ternaire.
switch(myInt) {  // switch case.
    case 5:
        // something.
        break;
    default:
        // something.
}

while(myFloat < 0.5f) {}  // while.
do {} while(myFloat < 0.5f);  // do while.
for(int i = 0; i < 5; i++) {}  // for.
for(String cel : myArray) {}  // foreach.
break;  // break.
continue;  // continue.

String[] myArray = {"a", "b", "c"};  // array string.
String[] myArray = new String[4];  // create an array without value, with a defined length.
myArray[0]  // indexor.
myArray.length  // length.

public class MyClass {}  // create a class.
MyClass a = new MyClass();  // instancie a class.
a.name;  // access parameter of an instance.
public MyClass() {}  // constructor.
this.a = a;  // affect parameters (in constructor).
public, private, protected  // encapsulation (word to define parameter or function acessibility), warning, protected in Java include same folder/sub-class.
static  // say this element (params or function), is unique of class (not distinct by instances).
import package.name.Class;  // import a class (replace "Class" by "*" for import all package).
public class A extends B {}  // eritage.
super();  // call the constructor parent (use it on the constructor child).
super.myFunction();  // call a function of the parent (word "super" refer to parent class).
abstract class myClass {}  // create a class abstract (can't be instanciate, only to use as eritage parent).
interface MyInterface {}  // create an interface (basicly a promess of what function should be on the class who implement it), syntax rule : all interface name start by "I".
public class MyClass implements MyInterface {}  // impelment an interface.
MyClass a = new MyClass() {
    public void myFunc() {};  // overide a methode on an instance create (for this instance only).
}

enum MyEnum {A, B, C}  // enum.
MyEnum a = MyEnum.A;  // call the value of the enum.
for (MyEnum cel : MyEnum.values()) {}  // foreach on an enum.
enum MyEnum {  // example of enum with instance, and parameters/function on it.
    A("value A"),
    B("value B");

    private String value;

    private MyEnum(String value) {
        this.value = value;
    }
    private String getValue() {
        return this.value;
    }
}

public void myFunc() {}  // function.
private static void myFunc() {}  // function (private AND static, example).
public bool myFunc() { return true; }  // function (with a return value).
public void myFunc(int myInt) {}  // function (with parameter).
public void myFunc(int[] myArr) {}  // function (with parameter array).
public void myFunc(int... myArr) {}  // function (with various amount of parameters).
(n) -> {}  // lambda.

public class MyClass<T> {}  // generic type (on class).
public class MyClass<T extends Number> {}  // add constraint eritage.
public T myParam;  // generic attribute (on a param).
public <T> void myFunc(T myParam) {}  // generic type (on function).

try {}  // try.
catch(Exception e) {}  // catch.
finally {}  // finally.
throw new Exception("message");  // throw.
public class MyException extends Exception {}  // create custom exception.

<dependency>  // importation JUnit (for test unitaire)
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.10.0</version>
    <scope>test</scope>
</dependency>
import org.junit.jupiter.api.Test;  // class test unitaire.
import static org.junit.jupiter.api.Assertions.*;
class MyUnitTestAdd {
    @Test
    void testAdd() {  // method test to try a specific case of execution call for the function.
        int result = MyClassAdd.add(5, 5);
        assertEquals(result, 10);
    }
}
mvn test  // run all test.
mvn -Dtest=MyUnitTestAdd test  // execute a named class test.
mvn -Dtest=MyUnitTestAdd#testAdd test  // execute a named methode test.

import java.util.regex.Matcher;
import java.util.regex.Pattern;  // can be merge both with "*".
Pattern pattern = Pattern.compile("^[a-z]$", Pattern.CASE_INSENSITIVE);  // build a regex.
Matcher matcher = pattern.matcher("my string");  // browse a string with a regex.
matcher.find();  // return true if regex is a match.
matcher.group();  // return matches string into base string.
matcher.groupCount();  // return the amount of match.
matcher.replaceAll("new string");  // return a string edited (replaced all matches).
matcher.replaceFirst("new string");  // retrun a strig edited (replaced the first matche).

@Test  // mark a methode as "test unitaire".
@Override  // mark a methode re-defined from the parent class.
@Deprecated  // mark a methode is discouraged to be used.
@SuppressWarning("unchecked")  // tell to the compiler to ignore certain warning (write what warning need to be ignored).

public class MyClass extends Thread {}  // extend a class from Thread, to be execute multi-threading.
public class MyClass implements Runnable {}  // same, but with an interface.
MyClass myThread = new MyClass();
myThread.start();  // launch the class thread (async).
Thread myThread = new Thread(new MyClass());
myThread.start();  // same, but with interface Runnable.
myThread.isAlive();  // return true if the thread is still executing.

import java.util.Collections;  // import list.
import java.util.ArrayList;  // import ArrayList.
import java.util.Comparator;  // import comparator (to define a comparator, on class using list, like sort).
// todo : list, array et set...









